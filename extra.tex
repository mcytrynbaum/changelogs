


---------------trying to prove w(pref) has no up-edges in sub1 
Since any such $\pre$ is processed at most once by the first statement of the lemma, by inspection the only possible addition of an edge to $\forest$ naming $\pre$ is of the form $(w(\pre^f),\pre)$ with $c(w(\pre^f)) = w(\pre)$.  
We claim that no directed edge of the form $(w', w(\pre^f))$ is ever added to $\forest$ during the subroutine. 
A directed edge $(w',w_j)$ is added only if $w_j \in \acto$ at some point during the algorithm. 
Let $\pre \in \acto$ and $\pre_j = \pre^f$. 
Then, by the monotonicity of the Tarski sequence for $\lag \pre \rag$, $\pre^f = \pre_j \peq \pre$.

Specifically, we show that our algorithm also gives a faster method of finding all Nash equilibria in games with strategic complementarities (GSC), extending the original work in Echenqiue xxxxx.  
We also show how a version of the cone geometry approach can be used to find all \emph{stable} matchings in the contracts model of Hatfield and Milgrom xxxx.  

Note that the set of preallocations $\prealloc$ is a finite product set endowed with a product order.
Thus, we can identify $\prealloc$ with a grid in Euclidena space, where, for instance, $\pre \in \prealloc$ corresponds to a point in $|A|$ dimensional Euclidean space with components given by the rank of $\pre(a)$ under the order $\su_a$. 

Our approach is very general, relying only on the lattice structure of the problem and the ability to define subproblems whose solutions contain the original points of interest.  

Therefore, by isotonicity of $T^2$, we have $T^4 \pre^* \pe \T^2 \pre^*$ and so on, so, by iterating $T^2$, we obtain a monotonically decreasing sequence, which, by finiteness of $\prealloc$ converges to a fixed point, which we call $\toppre$.
By a standard argument \footnote{insert standard argument}, $\toppre$ is the largest fixed point 

Fix $\acto^{0} = \acto$ at the beginning of 
Since we only add points to $\acto$ in line~\ref{alg1:addq}, we have $\actacum = \actocum$. 
By the proof above, $\acta = \emptyset$ when the subroutine terminates, so every $\pre \in \actacum$ is removed from $\acta$ at some point before termination.



Finally, we show that the outer while loop at line~\ref{alg3:while1} terminates.
Set $\acto^r \leftarrow InformationAcquire(\acto)$. 
We claim that if $\acto \not = \emptyset$, then $d(\acto^r) < d(\acto)$. 
Consider subroutine~\ref{infac} with input $\acto$. 
Let $\actacum$ be the collection of points ever added to $\acta$ and similarly for $\actocum$, which includes the initial value of $\acto$. 
We claim that no preallocation is ever added to $\acta$ more than once. 
Equivalently, since $\acta = \emptyset$ when the algorithm terminates, every point in $\actacum$ is removed from $\acta$ exactly once. 
Suppose not, and $\pre$ is added more than once. 
Consider the first time $\pre$ is added. 
If this is at line~\ref{alg1:add1}, then $\pre \in \acto \sub \act$.
Otherwise, this is at line~\ref{alg1:addq}, so we also add $\pre$ to $\act$.
Now consider the second time $\pre$ is added 
Then $\pre$ is added at line~\ref{alg1:addq}, $\pre = \pre' - e_i$ for some $1 \leq i \leq m$.


By work above, subroutine~\ref{infac} terminates.
Note that the operations in the for loop at line~\ref{alg1:for2} is deterministic and the removal code at lines~\ref{alg1:stop1} and~\ref{alg1:stop2} is mutually exclusive. 

\item For all $\pre_i \in \acto$, $w_i$ is a root of some tree in the forest.

\item If $k \in \coll(i)$ for some $i \in \mathcal{I}$ and $w_j = r(w_i)$, then $\pre_j \peq \pre_k$ \label{lemma:coll}

We show that $r(w_i) = w_i$. 
To do this, we show a result about the structure of $\forest'$, which will also be useful for case 4. 

Note first that, for any $\pre_{\ell} \in \actt$, we have $c(w_{\ell}) = \{r(w_k): v_k \in \strongcomp_j\}$ for some strong component $\strongcomp_j$. 
By disjointness of $\{\strongcomp_j\}_{j \in \mathcal{J}}$, the sets of children $c(w_{\ell})$ above are disjoint for all indices $\ell$. %not totally correct
Let $\forest'$ be the problem forest at the beginning of the for loop at line~\ref{alg2:for2}
Then, during this loop, each $w_{\ell}$ is added as a root joining a collection of disjoint trees in $\forest'$. 
Thus, $w_{\ell} \in \roott(F_n)$ for all $\pre_{\ell} \in \actt$, so this holdsfor $\ell = i$ in particular, and $r(w_i) = w_i$. 
We have, by the case assumption, $\pre_i \peq \pre_j \in \act$ for some $j$, so  condition~(\ref{convlemma:coll}) holds for $j \in \coll(i)$. 
Since the problem forest is unchanged, the conclusion for all other indices holds by the inductive hypothesis. 

deal with case where w(pre) is already in 
adding new? 
how do we know we are actually adding a vertex not yet in the forest....
same problem as above

Moreover, by disjointness, adding $w(\pre_j)$ to $\forest$ does not change any of the other root sets $\{r(w_k): v_k \in \strongcomp_{j'}\}$ associated with components $\strongcomp_{j'} \not = \strongcomp_j$. 
If an edge of the form $(w',w(\pre))$ is added during this process, then it must be that $w(\pre) \in \{r(w_k): v_k \in \strongcomp_{j'}\}$. 

This is impossible, since the root set $\{r(w_k): v_k \in \strongcomp_{j'}\}$ is unchanged until 

Fix $j' \not = j_1$, then, by disjointness of root sets $\{r(w_k): v_k \in \strongcomp_j\}$, adding $w(\pre_1)$ to $\forest'$ does not change any of the other root sets. 
Assume inductively 

$\{r(w_k): v_k \in \strongcomp_j\}$

By construction, $w(\pre)$ is added as a root, since its children are all roots (as in lemma~\ref{lemma:forest}). 
If $w(\pre) \not \in \roott(\forest'')$, then an edge of the form $(w',w(\pre))$ must have been added later during this for loop.  


------- proof about well definition 
We show that line~\ref{alg1:addq} above is well defined. 
That is, if we add a problem $\pre_j = \pre - e_i$, it must \emph{not} be part of the forest already. 
Suppose that this is not the case and $w_j \in \forest$ when we try to add it.
Then we condition on when $w_j$ was added. 
If $w_j$ was added during subroutine~\ref{infcomb}


------ need to figure out how to do this



In the algorithm for finding all strict core allocations presented above, we relied on an embedding of preallocations $\prealloc$ into a lattice in $\mr^m$, say, where $m = |A|$.

Here, we show that this Euclidean structure is not necessary and attempt to clarify the mathematical and economic aspects of the problem.

Following the discussion in section~\ref{section:general}, we show how to define isotonic operators $\Phi_i$ on sublattices $\lattice_i \sub \lattice$ that satisfy the required fixed point guarantee. 

for the induction - suffices to consider distinct states of $\acta$, because other state change indices are a subset // modulo changes that happen within for loop i.e. we look for changes up to for loop - this suffices
    should be - each is contained in some active problem, below, weakly, so that set is not empty and not just equal to $\pre$ for $\pre - e$

ok so 2 potential strats
    only if you actually are an old cone 
    if you cross an old cone 
        note: dont want to track all union relations - try to still get single processing condition
        that is - if your father is not in the cone but you are - this should also work, but does single processing? 
        the issue is that removing if it touches a top point is less efficient / arb given our strategy above, but let's see if it works first 

change setminus on $\acto$ - important 
change root proof to root before processed? 
can we stick with the single index thing? 
rather than doing that, we just add problems $\pre_i$, where we may have $\pre_j = \pre_i$ for $j \not = i$, seems bad...
add new statement to key tree lemma
break decreasing cone statement off into definition of problem tree? 
this gives a levels type of argument 
formalize acto root statement
prove a single-processing lemma 
break digraph construction off into a visual lemma? 
formalize acto root statement 
first prove, then go correct disjointness assumption
add note about roots after subroutine 1 
look for errors based on assuming that sub2 runs directly after sub1
add tree lemma references
solve the tree issue
ugh, we're not actually adding to root set in subroutine 2 
Let's show that all modifications are of form
    adding an element and joining root set elements to this as children 
    clear by edge and connectedness criterion that this gives a forest of the required form 
how do we know that active points are roots? - this also needs to be shown
proof of problem forest
make sure to prove this actually comes out as a tree - disjointness is the key part
what is the full ind hyp I will need to prove construction 
what form does the induction take / indices
need to include indices in induction
is there something super-formally wrong with doing induction like this? 
add indices statement to proof tagline
use equivalent condition for a tree that it is connected with n-1 vertices
adding children who have no parents - should be fine 
cut out some ugly things by resolving graph on the parents? 

then correct construction from algorithm 1 states implies correct chain 

add a reference - graph theory and its applications gross, yellen
add something above about how the algorithm makes use of 4 geometric facts 
add a note about complexity 
put in a max based removal step for Q
add a note about how pref is well-defined 


 
\begin{algorithm}
\caption{InformationAcquire - Subroutine for Stage 1}     
\label{infac}
\begin{algorithmic}[1]
\REQUIRE $\acto$
    \STATE Set $\acta \leftarrow \acto$ \label{alg1:add1}
    \STATE Set $\fixtemp \leftarrow \emptyset$ and $\actc \leftarrow \emptyset$ and $\coll \leftarrow \emptyset$
    \FOR{$\pre_i \in \acto$} \label{alg1:for1} 
        \IF[Remove redundant problems]{$\exists \pre_j \in \acto$ s.t. $\pre_i \pe \pre_j$ \OR $\pre_i \peq \min \fix(T^2)$}
            \STATE Remove $\pre_j$ from $\acta$, $\acto$, and $\act$ \label{alg1:stop0} \label{alg1:redundant}
        \ENDIF
    \ENDFOR
    \WHILE{$\acta \not = \emptyset$} \label{alg1:while1}
        \FOR{$\pre_i \in \acta$} \label{alg1:for2}
        \STATE $\pre \leftarrow \pre_i$
            \WHILE{$\pre_i \in \acta$} 
                \STATE Compute $\pre' = T_i^2 \pre$
                \IF[Stopping conditions 1 and 3]{$\pre' \peq \bopre$ \OR $\pre' = \pre$}
                    \STATE Remove $\pre_i$ from $\acta$ \label{alg1:stop1}
                    \STATE Set $\pref_i \leftarrow \pre'$; Add $w(\pref_i)$ to $F$ with $c(w(\pref_i)) = w(\pre_i)$ \label{alg1:tree1}
                    \IF[Stopping condition 2]{$T\pre = \pre$} 
                        \STATE Add $\pre$ to $\fixtemp$
                    \ELSIF{$\pre' = \pre$}
                        \FOR{$i = 1$ to $m$}
                            \IF[Add non-redundant problems]{$\nexists \pre'' \in \act$ with $\pre - e_i = \pre''$ } \label{alg1:redundant}
                                \STATE Add $\pre - e_i$ to $\acto$, $\acta$, and $\act$ \label{alg1:addq}
                                \STATE Add $w(\pre - e_i)$ to $\forest$ as an isolated root 
                            \ENDIF
                        \ENDFOR
                    \ENDIF
                \ELSE
                    \FOR{$\pre_j \in Q$}
                        \IF[Stopping condition 4]{$\pre' \peq \pre_j$ \AND $\pre_i \not \peq \pre_j$} \label{alg1:impact}
                            \STATE Remove $\pre_i$ from $\acta$ \label{alg1:stop2}
                            \STATE Set $\pref_i \leftarrow \pre'$; Add $w(\pref_i)$ to $F$ with $c(w(\pref_i)) = w(\pre_i)$  \label{alg1:tree2}
                            \STATE Add $\pre_i$ to $\actc$; Add $j$ to $\coll(i)$ \COMMENT{Build collision indices} \label{alg1:coll}
                        \ENDIF
                    \ENDFOR
                \ENDWHILE
            \ENDIF
        \ENDFOR
    \ENDWHILE
    \RETURN{$(\actc, \coll, \fixtemp)$} 
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{InformationCombine - Subroutine for Stage 2}  
\label{infcomb}
\begin{algorithmic}[1]
\REQUIRE $\acto$, $\coll$
    \STATE Set $V = E = \emptyset$
    \STATE Set $\actt = \emptyset$
    \FOR[Build collision digraph]{$\pre_i \in \acto$}
        \STATE Add $i$ to $\coll(i)$ \label{alg2:self_int}
        \STATE Add $v_i$ to $V$ \label{alg2:selfref}
        \FOR{$j \in \coll(i)$}
            \STATE Compute $w_k = r(w_j)$ \label{alg2:rootbuild}
            \STATE Add $v_k$ to $V$
            \STATE Add $(v_i,v_k)$ to $E$ %no multi-edges - only add once
        \ENDFOR
    \ENDFOR
    \STATE Set  $G = (V,E)$
    \STATE Compute strong components $\strongc$  of $G$
    \STATE Remove $\{v_k\}\in \strongc$ for $\pre_k \not \in \acto$, leaving components $\{S_j\}_{j \in \mathcal{J}}$ \label{alg2:cstrong}
    \FOR[Use $G$ to combine information]{$j \in \mathcal{J}$} \label{alg2:for2}
        \STATE Compute reachable component $\reach_j$ 
        \STATE Compute indices $K_j = \{k \in \mathcal{I}: v_k \in \strongcomp_j\}$ \label{alg2:indices}
        \STATE Set $\pre = \min_{k \in K_j} \pre_k$ and add to $\actt$
        \STATE Add $w(\pre)$ to $F$ with $c(w(\pre)) = \{r(w_k): v_k \in \strongcomp_j\}$ \label{alg2:forest}
    \ENDFOR
    \STATE Set $\coll(i) = \emptyset$ for $i \in \mathcal{I}$
    \FOR{$\pre_i \in \actt$} 
        \FOR{$\pre_k \in Q$}
            \IF{$\exists w_j \in c(w_i)$ s.t. $\pre_i \peq \pre_k$ \AND $\pre_j \not \peq \pre_k$} \label{alg2:collide}
                \STATE Add $k$ to $\coll(i)$ \label{alg2:coll2} 
            \ENDIF
        \ENDFOR
    \ENDFOR
    \STATE Set $\acto \leftarrow \actt$ 
    \STATE Set $\act \leftarrow \act \cup \actt$ \label{alg2:addq}
\RETURN{$(\acto,\coll)$} 
\end{algorithmic}
\end{algorithm}




\prf
We will show that at any point during the execution of FindStrictCore, a fixed point $\pre \in \fix(T)$ satisfies either (i) $\pre \in \fixfind$, the fixed points already found by the algorithm, or (ii) there exists a $\pre' \in \acto$ such that $\pre \peq \pre'$. 
We work by induction on $k$, the number of distinct states $\actok$ of the set of active problems $\acto$ during the main loop of FindStrictCore\footnote{Note that $\fixfind$ changes only if $\acto$ changes, so it suffices to consider distinct states of $\acto$}. 
For any set of problems $W$, we denote $\fix(W) \equiv \bigcup_{\pre \in W} \fix(\pre)$.

For the base case, note that if $\toppre \in \fix(T)$ or $\ul{\pre} \in \fix(T)$, then, by lemma~\ref{lemma:contain} above, $\fix(T) = \{\toppre\}$ or $\{\ul{\pre}\}$, so the algorithm is correct. 
Suppose the algorithm continues, and we set $\acto = \bigcup_{i = 1}^m \{\toppre - e_i\}$ (identifying $\prealloc$ with a grid as above).
Since $\fix(T) \peq \toppre = \max \fix(T^2)$ and $\toppre \not \in \fix(T)$, the inductive hypothesis is clearly satisfied. 
Then suppose by induction that (i) and (ii) above are satisfied up to $k = n$.
We show that these statements still hold for $k = n +1$.

Throughout, for a set $E$, we let $E'$ denote the state of $E$ at subroutine initialization, and $E''$ its state at algorithm return.
There are two main cases, corresponding to each subroutine.

\emph{Case 1}: There is a state change $\actok \to \acto^{k +1}$ and $\fixfindk \to \fixfindkk$ when InformationAcquire (subroutine 1) returns.
InformationAcquire returns a set $\actc$ of ``collided'' problems, which will be combined during subroutine 2.
In the above notation, $\actc'' = \acto^{k+1}$ is the set of problems and $\fixtemp''$ is the set of fixed points returned by the subroutine.
By the inductive hypothesis, we have $\fix(T) \sub \fixfind' \cup \fix(\acto')$.
Then, to show that no fixed points are ``lost'' during the subroutine, it suffices to show that $\fix(\acto') \sub \fixtemp'' \cup \fix(\actc'')$.

Formally, we work by induction on $\ell \geq 0$ (\emph{within} this subroutine), for distinct states of the tuple \[(\acta,\acto,\actc,\fixtemp)_{\ell}\]
Note that, by inspection of the algorithm, the last three sets in the tuple change \emph{only if} $\acta$ changes. 
Therefore, it suffices to consider distinct states\footnote{Note that by ``distinct states'' we mean distinct states that occur at \emph{different} iterations of the processing loop at line~\ref{alg1:for1}.
Thus, we are allowed to remove a fixed point from $\acta \cup \actc$ and add it back later while processing a single problem $\pre_i$ without creating a ``distinct'' state.} of the working set of active problems $\acta$.
We will show by induction that for any $\ell \geq 0$ if $\pre'' \in \fix(\pre)$ for some problem $\pre \in \acto^{\ell}$ then either $\pre'' \in \fixtemp^{\ell}$ or there exists $\pre' \in \acta^{\ell} \cup \actc^{\ell}$ with $\pre'' \peq \pre' \peq \pre$ (GAR).
We call such a relationship a guarantee (GAR) on $\pre''$ \emph{afforded} by the problem $\pre' \in \acta^{\ell} \cup \actc^{\ell}$, which is either still active, or in the set of ``collided'' problems to be returned by the algorithm.
In particular, this will show that $\fix(\acto^{\ell}) \sub \fix(\acta^{\ell}) \cup \fix(\actc^{\ell}) \cup \fixtemp^{\ell}$ for all $\ell \geq 0$.
By lemma~\ref{lemma:termination}, this subroutine terminates with $\acta'' = \emptyset$. 
Also, as we will show shortly, $\fix(\acto') \sub \fix(\acto'')$, where $\acto''$ is the state of $\acto$ when the algorithm returns. 
Then, assuming the inductive result above, we would have $\fix(\acto') \sub \fix(\acto'') \sub \fix(\acta'') \cup \fix(\actc'') \cup \fixtemp'' = \fix(\actc'') \cup \fixtemp''$, so that no fixed points are ``lost'' during this subroutine.

First, we show that $\fix(\acto') \sub \fix(\acto'')$. 
Consider the beginning of subroutine 1, where we remove redundant subproblems (line~\ref{alg1:redundant}).
If $\pre \in \acto'$ and $\pre \peq \min \fix(T^2)$, then $\fix(\pre) = \emptyset$ since we checked $\bopre = \min \fix(T^2) \not \in \fix(T)$. 
Otherwise, if we remove $\pre$ from $\acto$ during this loop, then there is a $\pre \peq \pre' \in \acto$, so that $\fix(\pre) \sub \fix(\pre')$, and no fixed points are lost.
Let $\acto^R$ denote the state of $\acto$ after this removal step.
Then $\fix(\acto^R) = \fix(\acto')$.
After this step, we only add, never remove, points from $\acto$, so we have $\fix(\acto') \sub \fix(\acto^R) \sub \fix(\acto'')$, as required.

We now begin the induction.
The base case is clear, since we set $\acta' \leftarrow \acto'$ at initialization.
Then suppose by induction that our hypothesis holds up to $\ell = k$.
We will show that guarantees of the form (GAR) above still exist for all $\pre \in \fix(\actokk)$.
By the argument above, it suffices to consider changes to $\acta$ after redundant problem removal (line~\ref{alg1:redundant}), since no fixed points guarantees are lost during this step.
There are several cases.

\emph{Subcase 1}: There is a state change $\actak \to \actakk$ when stopping condition (1) or (2) is triggered for a problem $\pre_i \in \actak$, which is then removed $\actakk \leftarrow \actak \setminus \{\pre_i\}$.
Let $\pren \in \actok$ and $\pre \in \fix(\pren)$ and suppose that $\pre \not \in \fixtempkk$, the set of fixed points found by $\ell = k + 1$.
We show that the guarantee (GAR) on $\pre$ cannot be afforded by $\pre_i$, so it is safe to remove $\pre_i$ from $\actak \cup \actck$.
Suppose that $\pre \peq \pre_i$.
We have $\pre' = (T_i^2)^k \pre_i$ for some $k \geq 0$, and $\pre' \peq \bopre$ or $T \pre' = \pre'$.
By the Tarski argument discussed earlier in the text, $\fix(\pre_i) \sub \fix(\pre')$, so, in fact, $\pre \peq \pre'$.
But $\pre \not = \pre'$, since we check if $\pre' \in \fix(T)$ when processing $\pre_i$, and we assumed $\pre' \in \fixtempkk}$.
Then $\pre \pe \pre'$ strictly.
For stopping condition (1), note that $\fix(T) \sub \fix(T^2) \succeq \bopre$.
Combining these, $\pre \pe \pre' \peq \bopre$, which is a contradiction.
For stopping condition (2), note that by lemma~\ref{lemma:top}, which shows that no fixed points of $T$ are ordered strictly by ``$\pe$'', if $T\pre' = \pre'$ then there can be no $\pre \pe \pre'$ fixed by $T$, so this also results in a contradiction. 
By the inductive hypothesis, there must be $\pre'' \not = \pre_i$ such that $\pre'' \in \actak \cup \actck$ and affords a guarantee $\pre \peq \pre'' \peq \pren$.
Then $\pre'' \in \actakk \cup \actckk$ since it is not removed, so we are done.

\emph{Subcase 2}: There is a state change $\actak \to \actakk$ when stopping condition (3) is triggered for a problem $\pre_i \in \actak$.
Again, we have $\pre'$ the lowest element of the Tarski sequence, and, as above, $\fix(\pre_i) \sub \fix(\pre')$.
We then remove $\pre_i$ and add $\pre' - e_i$ for $1 \leq i \leq m$, so $\actakk = \actak \setminus \{\pre_i \} \cup \left (\bigcup_{i \in I} \{\pre' - e_i \} \right )$, where $I \sub \{1,\hdots,m\}$ are the indices such that $\pre' - e_i$ is non-redundant (as in line~\ref{alg1:addq}).
Let $\pre \in \fix(\pren)$ for $\pren \in \acto$, and suppose that $\pre \not \in \fixtempkk}$, so we need to show that there exists some guarantee for $\pre$.
Suppose $\pre \peq \pre_i \peq \pren$ as in (GAR) above, so that $\pre \peq \pre'$ by the Tarski argument.
In fact, $\pre \pe \pre'$, because we check if $\pre' \in \fix(T)$, as in the previous case.
Then we must have, $\pre \peq \pre' - e_i$ for some $i$.
If $i \in I$ then $\pre \peq \pre' - e_i \pe \pre' \peq \pren$, so $\pre' - e_i \in \actakk$ gives a new guarantee (GAR) on this fixed point for $\pren \in \acto$.
No other points of $\actak \cup \actck$ are removed, so we are done.
Suppose, conversely, that $i \not \in I$; that is, the problem $\pre' - e_i$ is redundant.
Then $\pre - e_i = \pre'' \in \actk$. 
Note that by induction, we have $\fix(Q') \sub \fix(T) \sub \fix(\acto') \cup \fixfind^k$




so we actually have $\pre \in \fix(\pre'') \cap \fix(\pren)$.
By working with the guarantee (GAR) for $\pre'' \in \actok$ (rather than the guarantee for $\pren \in \actok$), by the inductive hypothesis for $\ell = k$ there exists $\pre_g \in \actak \cup \actck$ such that $\pre \peq \pre_g \peq \pre'' = \pre' - e_i \pe \pre' \peq \pre_i$.
Then $\pre_g \not = \pre_i$, so, in particular, it is not removed at step $k+1$, and we have $\pre_g \in \actakk \cup \actckk$.
Then, in either case, we still have a guarantee on all fixed points.

\emph{Subcase 3}: There is a state change $\actak \to \actakk$ when stopping condition (4) is triggered for a problem $\pre_i \in \actak$.
Note that in this case we just move $\pre_i$ between sets.
Specifically, $\actakk = \actak \setminus \{\pre_i\}$ and $\actckk = \actck \cup \{\pre_i\}$.
Then $\actak \cup \actck = \actakk \cup \actckk$, so none of the guarantees of the form (GAR) above can change, which finishes the subcases.

By the remarks at the beginning and since the algorithm terminates by lemma~\ref{lemma:termination}, we have shown by induction that $\fix(\acto') \sub \fix(\actc'') \cup \fixtemp''$, so we are done.
Returning to the first induction, we have shown that in the case where $\actok \to \actokk$ during InformationAcquire (subroutine 1), we have, using the inductive hypothesis, that $\fix(T) \sub \fix(\actok) \cup \fixfindk \sub \fix(\actokk) \cup \fixfindk \cup \fixtemp'' = \fix(\actokk) \cup \fixfindkk$.

\emph{Case 2}: There is a state change $\actok \to \acto^{k +1}$ when InformationCombine (subroutine 2) returns.
In the notation above, $\acto'$ is the input to the subroutine, and $\actt'' = \actokk$ is the set returned by the subroutine. 
We will argue that, for any $\pre \in \acto'$, there is a $\pre' \in \actt''$ such that $\fix(\pre) \sub \fix(\pre')$.
It will follow immediately that $\fix(\actok) = \fix(\acto') \sub \fix(\actt'') = \fix(\actokk)$.
The proof relies crucially on the collision digraph and problem forest structure results developed above.

Fix $\pre_i \in \acto'$.
By construction, we have $v_i \in G$, where $G = (V,E)$ is the collision digraph built during the algorithm.
Then $v_i \in \strongcomp_j$, a strong component of $G$ left over after trimming irrelevant singletons (line~\ref{alg2:cstrong}).
By our key lemma~\ref{lemma:forest} on the structure of the rooted forest $\forest$ during the algorithm, $\forest$ is a problem forest, as in definition~\ref{def:forest}, at any time during the execution of FindStrictCore.
Moreover, condition~(\ref{convlemma:coll}) of lemma~\ref{lemma:forest} also holds, showing that collision indices are compatible with $\forest$.
Then proposition~\ref{prop:graph}, our result showing that fixed point relationships are reflected in the structure of the collisiion digraph, can be applied. 
Let $\reach_j$ denote the reachable set of strong component $\strongcomp_j$.
By item~(\ref{prop:graph:reach}) of the graph structure proposition, if $\pre_k \in \reach_j$, then $\fix(\pre_i) \peq \pre_k$.
If $K_j$ denotes the set of indices associated with $\reach_j$ (as in line~\ref{alg2:indices}), we have $\fix(\pre_i) \peq \min_{k \in K_j} \pre_k \equiv \pre'$, which is added to $\actt$.
In particular, $\fix(\pre_i) \sub \fix(\pre')$, where $\pre' \in \actt'' = \actokk$.
This shows that $\fix(\actok) \sub \fix(\actokk)$, so, in particular, $\fix(\actok) \cup \fixfindk \sub \fix(\actokk) \cup \fixfindkk$ since $\fixfindk = \fixfindkk$.

We have exhausted both cases, so this completes the induction. 
By our termination analysis in lemma~\ref{lemma:termination}, $\acto = \emptyset$ when the algorithm returns, so we have shown that $\fix(T) \sub \fix(\acto) \cup \fixfind = \fixfind$.
Moreover, we only add $\pre$ to $\fixfind$ after checking that $T\pre = \pre$, so clearly $\fixfind \sub \fix(T)$.
Then $\fixfind = \fix(T)$. 
That is, by lemma~\ref{lemma:strictcore} and lemma~\ref{lemma:coordinated} above, for any $\pre \in \fixfind$, we have $\pre = \pre_Y$ for some $Y \in \strcore$, and this exhausts all strict core allocations. 
\eprf

From a computational complexity perspective, evaluating the $T$ operator is equivalent to checking whether or not a specific allocation $Y$ is in the strict core.
This operation can be very costly even in classical matching models\footnote{add some concrete complexity reference}.
Our algorithm attempts to minimize the number of evaluations of $T^2$ by using lattice geometry to combine the information from related subproblems. 

\begin{enumerate}
\item $\pre \peq \ul{\pre} = \min \fix(T^2)$ 
\item $T \pre = \pre$
\item $S_i \pre = \pre$
\item $\pre \peq \pre'$ for some $\pre' \in Q$ with $\pre_i \not \peq \pre'$ 
\end{enumerate} 

In case (1), $\fix(\pre_i) \peq \min \fix(T^2)$, so $\fix(\pre_i) = \emptyset$, and we may stop iteration. 
In case (2), $\pre = S_i^k \pre_i$ is fixed by $T$, so, by lemma~\ref{lemma:contain}, $\fix(T) \cap \{\pre' \pe \pre \} = \emptyset$.
That is, we can stop searching this problem.
In case (3), the Tarski sequence for $\pre_i$ stops, so we stop the problem $\lag \pre_i \rag$ below $\pre$ and form new subproblems $\lag \pre - e_j \rag$ for $j = 1 \hdots m$, each of which we add to $\acto$.  
In case (4), we have learned that $\fix(\pre_i) \sub \fix(\pre')$ for some other problem $\pre'$, so we stop work on $\pre_i$ and wait for the next stage of the algorithm, where we will combine the fixed point guarantees on $\fix(\pre')$ with those on $\fix(\pre_i)$.
We let $\pref_i$ denote the final value of $\pre$ in the Tarski sequence for $\lag \pre_i \rag$ when one of the stopping conditions above is triggered. 




